Thursday 27 Nov
-I read the two articles during the morning.
-Question: Do I need to compute the whole reflection group? 
-I start programming the inputs and the matrices in python
Friday 28 Nov
-In class we discuss that if we only need to compute the size of the orbit, the group generators are enough to compute the orbit.
-Due to the size of some orbits and the appearance in the matrices of Tau I see that I may have some precision issues if I work with real numbers, so I decide to program in C++ and look for some kind of variable definition that allows ring extensions
-I 'reprogram' the inputs and the matrices but as if I was dealing with integers only (I will look for the ring extension structure later)
week 28 Nov - 5 dec
-I forget to enter changes in the diary
-Mostly I code all the program without taking into account floating point problems (with "real-valued" variables). My goal is to make sure everything does what is supposed and then work on refining the code.
Friday 5 dec
-I have decided to take v at random if not given to the program
-when compiling: correct some typos, problems with rand(),(There was a missing library)
-My program works! it is quite funny I have managed to obtain the desired results in less time than the table however I have to run the program several times to get the result (if the random vector is "good" I get a good result, if not I get a bigger orbit, maybe I can make the intern program run several times and look for the smallest result- this would be evil)

-refine selection of vector in the following way: the elements of the vector are different between themselves (most hiperplanes just change coordinates), distance from the hyperplane is high enough.
-Still I get higher orbits for small seized inputs. I should probably allow some tolerance when checking for equality of vectors but I have no more time

Tuesday 9 Dec
-This weekend due to recursion issues the program output segmentation faults for big entries (classic stack overflow seg fault)
-programming sets and queues my program is much more fast
-avoiding recursion and using iteration my program works fast for big entries A and D cases are solved quite efficently
-Allowing some tolerance in the doubles H3 works however not H4. For some reason that is not the precision F4 does not work and outputs an orbit of 576 when 1152 is expected (the double exactly) Probably because of the chosen vector for initialization!!.
-Solved the problem for F4.

Some running times (for matrices in which correct answers are obtained):

Ai i<7 <2sec
A7 2sec
A8 23.5sec
F4 0.26sec
Di i<7 <1sec
D7 15.5sec
H3 0.003sec

-Still does not work due to precision issues H4.
-started executing E8: after all night 30 milion elements had been found.

Wednesday 10 Dec

-Stoped execution of E8
-Running time D8 5m12.968sec
-Executed E8 on a remote computer (combgraph) (17:00) waiting...





